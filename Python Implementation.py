# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XrWvrESoDXdPWhf8Q-ceI69I56NzM_gv
"""

import numpy as np
import math as mt

def DFT_1D(fx):
    fx = np.asarray(fx, dtype=complex)      #storing as an array
    M = fx.shape[0]                         #calculating size
    fu = fx.copy()

    for i in range(M):
        u = i
        sum = 0
        for j in range(M):
            x = j
            tmp = fx[x]*np.exp(-2j*np.pi*x*u*np.divide(1, M, dtype=complex))  #multiplying with e^(i*2pie*n*k/N)
            sum += tmp                                                        #summation

        fu[u] = sum

    return fu

def FFT_1D(fx):
    fx = np.asarray(fx, dtype=complex) 
    M = fx.shape[0]                                     #size of input
    minDivideSize = 2

    if M % 2 != 0:
        raise ValueError("the input size must be 2^n")   #if input size not power of 2

    if M <= minDivideSize:
        return DFT_1D(fx)                                 #for input of size <=2
    else:
        fx_even = FFT_1D(fx[::2])                            # recursive call for  the even part 
        fx_odd = FFT_1D(fx[1::2])                           # recursive call for  the odd part
        W_ux_2k = np.exp(-2j * np.pi * np.arange(M) / M)    #e^(i*2pie*n*k/N)

        f_u = fx_even + fx_odd * W_ux_2k[:M//2]             #multiplying with e^(i*2pie*n*k/N)   

        f_u_plus_k = fx_even + fx_odd * W_ux_2k[M//2:]

        fu = np.concatenate([f_u, f_u_plus_k])              # summing up the even and odd parts

    return fu

def inverseFFT_1D(fu):
    fu = np.asarray(fu, dtype=complex) #storing input in an array
    fu_conjugate = np.conjugate(fu)    #taking conjuagte of inputs

    fx = FFT_1D(fu_conjugate)

    fx = np.conjugate(fx)              #again taking conjuate to get our answers in sequence correspong to input sequence
    fx = fx / fu.shape[0]

    return fx





"Input and Initialization"
n = int(input("Enter number of elements (must be a power of 2) : "))
 
lst = [ ]
# iterating till the range
for i in range(0, n):
    ele = input()
 
    lst.append(ele) # adding the element

print(lst)
y=inverseFFT_1D(lst)
print(y)